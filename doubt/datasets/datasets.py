''' 
Collection of data sets for regression tasks, with data preparation pipelines.
All data sets are from the UCI data set archive, with all the descriptions 
being the original descriptions verbatim. Some feature names were constructed
from their descriptions and were not part of the original data set.
'''

from ._dataset import BaseDataset

import pandas as pd
import zipfile
import io

BASE_DATASET_DESCRIPTION = '''
    Parameters:
        cache (str or None):
            The name of the cache. It will be saved to ``cache``.h5 in the
            current working directory. If None then no cache will be saved.
            Defaults to '.cache'.

    Attributes:
        shape (tuple of integers): 
            Dimensions of the data set
        columns (list of strings): 
            List of column names in the data set

    Class attributes:
        url (string):
            The url where the raw data files can be downloaded
        feats (iterable):
            The column indices of the feature variables
        trgts (iterable):
            The column indices of the target variables

    Methods:
        head(n: int = 5) -> pd.DataFrame: 
        to_pandas() -> pandas.DataFrame: 
        close() -> None:
        split(test_size: float or None = None, 
              seed: float or None = None) -> Tuple of Numpy arrays
'''

class Airfoil(BaseDataset):
    f'''
    The NASA data set comprises different size NACA 0012 airfoils at various 
    wind tunnel speeds and angles of attack. The span of the airfoil and the 
    observer position were the same in all of the experiments.   

    {BASE_DATASET_DESCRIPTION}

    Features:
        int: Frequency, in Hertzs
        float: Angle of attack, in degrees
        float: Chord length, in meters
        float: Free-stream velocity, in meters per second
        float: Suction side displacement thickness, in meters

    Targets:
        float: Scaled sound pressure level, in decibels
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Airfoil+Self-Noise 

    Examples:
        Load in the data set:
        >>> dataset = Airfoil()
        >>> dataset.shape
        (1503, 6)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (1503, 5) (1503, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (1179, 5) (1179, 1) (324, 5) (324, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00291/airfoil_self_noise.dat'

    feats = range(5)
    trgts = [5]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a data frame
        df = pd.read_csv(csv_file, sep = '\t', header = None)
        return df

class BikeSharingDaily(BaseDataset):
    f'''
    Bike sharing systems are new generation of traditional bike rentals where 
    whole process from membership, rental and return back has become automatic.
    Through these systems, user is able to easily rent a bike from a 
    particular position and return back at another position. Currently, there 
    are about over 500 bike-sharing programs around the world which is 
    composed of over 500 thousands bicycles. Today, there exists great 
    interest in these systems due to their important role in traffic, 
    environmental and health issues.

    Apart from interesting real world applications of bike sharing systems, 
    the characteristics of data being generated by these systems make them 
    attractive for the research. Opposed to other transport services such as 
    bus or subway, the duration of travel, departure and arrival position is 
    explicitly recorded in these systems. This feature turns bike sharing 
    system into a virtual sensor network that can be used for sensing mobility 
    in the city. Hence, it is expected that most of important events in the 
    city could be detected via monitoring these data. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        instant (int): 
            Record index
        season (int): 
            The season, with 1 = winter, 2 = spring, 3 = summer and 4 = autumn
        yr (int): 
            The year, with 0 = 2011 and 1 = 2012
        mnth (int): 
            The month, from 1 to 12 inclusive
        holiday (int): 
            Whether day is a holiday or not, binary valued
        weekday (int): 
            The day of the week, from 0 to 6 inclusive
        workingday (int): 
            Working day, 1 if day is neither weekend nor holiday, otherwise 0
        weathersit (int): Weather, encoded as follows:
            1: Clear, few clouds, partly cloudy
            2: Mist and cloudy, mist and broken clouds, mist and few clouds
            3: Light snow, light rain and thunderstorm and scattered clouds,
               light rain and scattered clouds
            4: Heavy rain and ice pallets and thunderstorm and mist, or snow
               and fog
        temp (float): 
            Max-min normalised temperature in Celsius, from -8 to +39
        atemp (float): 
            Max-min normalised feeling temperature in Celsius, from -16 to +50
        hum (float): 
            Scaled max-min normalised humidity, from 0 to 1
        windspeed (float): 
            Scaled max-min normalised wind speed, from 0 to 1

    Targets:
        casual (int): 
            Count of casual users
        registered (int): 
            Count of registered users
        cnt (int): 
            Sum of casual and registered users
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset

    Examples:
        Load in the data set:
        >>> dataset = BikeSharingDaily()
        >>> dataset.shape
        (731, 15)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (731, 12) (731, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (562, 12) (562, 3) (169, 12) (169, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00275/Bike-Sharing-Dataset.zip'

    feats = range(12)
    trgts = [12, 13, 14]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out day.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('day.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, usecols = [0] + list(range(2, 16)))
        return df

class BikeSharingHourly(BaseDataset):
    f'''
    Bike sharing systems are new generation of traditional bike rentals where 
    whole process from membership, rental and return back has become automatic.
    Through these systems, user is able to easily rent a bike from a 
    particular position and return back at another position. Currently, there 
    are about over 500 bike-sharing programs around the world which is 
    composed of over 500 thousands bicycles. Today, there exists great 
    interest in these systems due to their important role in traffic, 
    environmental and health issues.

    Apart from interesting real world applications of bike sharing systems, 
    the characteristics of data being generated by these systems make them 
    attractive for the research. Opposed to other transport services such as 
    bus or subway, the duration of travel, departure and arrival position is 
    explicitly recorded in these systems. This feature turns bike sharing 
    system into a virtual sensor network that can be used for sensing mobility 
    in the city. Hence, it is expected that most of important events in the 
    city could be detected via monitoring these data. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        instant (int): 
            Record index
        season (int): 
            The season, with 1 = winter, 2 = spring, 3 = summer and 4 = autumn
        yr (int): 
            The year, with 0 = 2011 and 1 = 2012
        mnth (int): 
            The month, from 1 to 12 inclusive
        hr (int): 
            The hour of the day, from 0 to 23 inclusive
        holiday (int): 
            Whether day is a holiday or not, binary valued
        weekday (int): 
            The day of the week, from 0 to 6 inclusive
        workingday (int): 
            Working day, 1 if day is neither weekend nor holiday, otherwise 0
        weathersit (int): Weather, encoded as follows:
            1: Clear, few clouds, partly cloudy
            2: Mist and cloudy, mist and broken clouds, mist and few clouds
            3: Light snow, light rain and thunderstorm and scattered clouds,
               light rain and scattered clouds
            4: Heavy rain and ice pallets and thunderstorm and mist, or snow
               and fog
        temp (float): 
            Max-min normalised temperature in Celsius, from -8 to +39
        atemp (float): 
            Max-min normalised feeling temperature in Celsius, from -16 to +50
        hum (float): 
            Scaled max-min normalised humidity, from 0 to 1
        windspeed (float): 
            Scaled max-min normalised wind speed, from 0 to 1

    Targets:
        casual (int): 
            Count of casual users
        registered (int): 
            Count of registered users
        cnt (int): 
            Sum of casual and registered users
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset

    Examples:
        Load in the data set:
        >>> dataset = BikeSharingHourly()
        >>> dataset.shape
        (17379, 16)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (17379, 13) (17379, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (13878, 13) (13878, 3) (3501, 13) (3501, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00275/Bike-Sharing-Dataset.zip'

    feats = range(14)
    trgts = [13, 14, 15]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out hour.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('hour.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, usecols = [0] + list(range(2, 17)))
        return df

class Blog(BaseDataset):
    f'''
    This data originates from blog posts. The raw HTML-documents
    of the blog posts were crawled and processed.
    The prediction task associated with the data is the prediction
    of the number of comments in the upcoming 24 hours. In order
    to simulate this situation, we choose a basetime (in the past)
    and select the blog posts that were published at most
    72 hours before the selected base date/time. Then, we calculate
    all the features of the selected blog posts from the information
    that was available at the basetime, therefore each instance
    corresponds to a blog post. The target is the number of
    comments that the blog post received in the next 24 hours
    relative to the basetime.

    In the train data, the basetimes were in the years
    2010 and 2011. In the test data the basetimes were
    in February and March 2012. This simulates the real-world
    situtation in which training data from the past is available
    to predict events in the future.

    The train data was generated from different basetimes that may
    temporally overlap. Therefore, if you simply split the train
    into disjoint partitions, the underlying time intervals may
    overlap. Therefore, the you should use the provided, temporally
    disjoint train and test splits in order to ensure that the
    evaluation is fair.

    {BASE_DATASET_DESCRIPTION}

    Features:
        Features 0-49 (float):
            50 features containing the average, standard deviation,
            minimum, maximum and median of feature 50-59 for the source
            of the current blog post, by which we mean the blog on which
            the post appeared. For example, myblog.blog.org would be the
            source of the post myblog.blog.org/post_2010_09_10
        Feature 50 (int):
            Total number of comments before basetime
        Feature 51 (int):
            Number of comments in the last 24 hours before the basetime
        Feature 52 (int):
            If T1 is the datetime 48 hours before basetime and T2 is the
            datetime 24 hours before basetime, then this is the number of
            comments in the time period between T1 and T2
        Feature 53 (int):
            Number of comments in the first 24 hours after the publication
            of the blog post, but before basetime
        Feature 54 (int):
            The difference between Feature 51 and Feature 52
        Features 55-59 (int):
            The same thing as Features 50-51, but for links (trackbacks)
            instead of comments
        Feature 60 (float):
            The length of time between the publication of the blog post
            and basetime
        Feature 61 (int):
            The length of the blog post
        Features 62-261 (int):
            The 200 bag of words features for 200 frequent words of the
            text of the blog post
        Features 262-268 (int):
            Binary indicators for the weekday (Monday-Sunday) of the basetime
        Features 269-275 (int):
            Binary indicators for the weekday (Monday-Sunday) of the date
            of publication of the blog post
        Feature 276 (int):
            Number of parent pages: we consider a blog post P as a parent
            of blog post B if B is a reply (trackback) to P
        Features 277-279 (float):
            Minimum, maximum and average of the number of comments the
            parents received

    Targets:
        int: The number of comments in the next 24 hours (relative to
             baseline)
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/BlogFeedback 

    Examples:
        Load in the data set:
        >>> dataset = Blog()
        >>> dataset.shape
        (52397, 281)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (52397, 279) (52397, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (41932, 279) (41932, 1) (10465, 279) (10465, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00304/BlogFeedback.zip'

    feats = range(279)
    trgts = [279]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out blogData_train.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('blogData_train.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, header = None)
        return df

class Nanotube(BaseDataset):
    f'''
    CASTEP can simulate a wide range of properties of materials proprieties 
    using density functional theory (DFT). DFT is the most successful method 
    calculates atomic coordinates faster than other mathematical approaches, 
    and it also reaches more accurate results. The dataset is generated with 
    CASTEP using CNT geometry optimization. Many CNTs are simulated in CASTEP, 
    then geometry optimizations are calculated. Initial coordinates of all 
    carbon atoms are generated randomly. Different chiral vectors are used for 
    each CNT simulation. 
    
    The atom type is selected as carbon, bond length is used as 1.42 AÂ° 
    (default value). CNT calculation parameters are used as default 
    parameters. To finalize the computation, CASTEP uses a parameter named 
    as elec_energy_tol (electrical energy tolerance) (default 1x10-5 eV) 
    which represents that the change in the total energy from one iteration to 
    the next remains below some tolerance value per atom for a few 
    self-consistent field steps. Initial atomic coordinates (u, v, w), chiral 
    vector (n, m) and calculated atomic coordinates (u, v, w) are 
    obtained from the output files.

    {BASE_DATASET_DESCRIPTION}

    Features:
        Chiral indice n (int): 
            n parameter of the selected chiral vector
        Chiral indice m (int): 
            m parameter of the selected chiral vector
        Initial atomic coordinate u (float): 
            Randomly generated u parameter of the initial atomic coordinates 
            of all carbon atoms. 
        Initial atomic coordinate v (float): 
            Randomly generated v parameter of the initial atomic coordinates 
            of all carbon atoms. 
        Initial atomic coordinate w (float): 
            Randomly generated w parameter of the initial atomic coordinates 
            of all carbon atoms. 

    Targets:
        Calculated atomic coordinates u (float): 
           Calculated u parameter of the atomic coordinates of all 
           carbon atoms 
        Calculated atomic coordinates v (float): 
           Calculated v parameter of the atomic coordinates of all 
           carbon atoms 
        Calculated atomic coordinates w (float): 
           Calculated w parameter of the atomic coordinates of all 
           carbon atoms 
    
    Sources:
        https://archive.ics.uci.edu/ml/datasets/Carbon+Nanotubes
        https://doi.org/10.1007/s00339-016-0153-1
        https://doi.org/10.17341/gazimmfd.337642

    Examples:
        Load in the data set:
        >>> dataset = Nanotube()
        >>> dataset.shape
        (10721, 8)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (10721, 5) (10721, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (8542, 5) (8542, 3) (2179, 5) (2179, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00448/carbon_nanotubes.csv'

    feats = range(5)
    trgts = [5, 6, 7]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, sep = ';', decimal = ',')
        return df

class Concrete(BaseDataset):
    f'''
    Concrete is the most important material in civil engineering. The concrete 
    compressive strength is a highly nonlinear function of age and 
    ingredients. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        Cement (float): 
            Kg of cement in an m3 mixture
        Blast Furnace Slag (float): 
            Kg of blast furnace slag in an m3 mixture
        Fly Ash (float): 
            Kg of fly ash in an m3 mixture
        Water (float): 
            Kg of water in an m3 mixture
        Superplasticiser (float): 
            Kg of superplasticiser in an m3 mixture
        Coarse Aggregate (float): 
            Kg of coarse aggregate in an m3 mixture
        Fine Aggregate (float): 
            Kg of fine aggregate in an m3 mixture
        Age (int): 
            Age in days, between 1 and 365 inclusive

    Targets:
        Concrete Compressive Strength (float): 
            Concrete compressive strength in megapascals
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Concrete+Compressive+Strength

    Examples:
        Load in the data set:
        >>> dataset = Concrete()
        >>> dataset.shape
        (1030, 9)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (1030, 8) (1030, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (801, 8) (801, 1) (229, 8) (229, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'concrete/compressive/Concrete_Data.xls'

    feats = range(8)
    trgts = [8]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        xls_file = io.BytesIO(data)

        # Load the file-like object into a data frame
        df = pd.read_excel(xls_file)
        return df

class CPU(BaseDataset):
    f'''
    Relative CPU Performance Data, described in terms of its cycle time, 
    memory size, etc. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        vendor_name (string): 
            Name of the vendor, 30 unique values
        model_name (string):
            Name of the model
        myct (int):
            Machine cycle time in nanoseconds
        mmin (int):
            Minimum main memory in kilobytes
        mmax (int):
            Maximum main memory in kilobytes
        cach (int):
            Cache memory in kilobytes
        chmin (int):
            Minimum channels in units
        chmax (int):
            Maximum channels in units

    Targets:
        prp (int):
            Published relative performance
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Computer+Hardware

    Examples:
        Load in the data set:
        >>> dataset = CPU()
        >>> dataset.shape
        (209, 9)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (209, 8) (209, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (158, 8) (158, 1) (51, 8) (51, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'cpu-performance/machine.data'

    feats = range(8)
    trgts = [8]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Name the columns
        cols = ['vendor_name', 'model_name', 'myct', 'mmin', 'mmax',
                'cach', 'chmin', 'chmax', 'prp']

        # Load the file-like object into a data frame
        df = pd.read_csv(csv_file, header = None, usecols = range(9),
                         names = cols)
        return df

class PowerPlant(BaseDataset):
    f'''
    The dataset contains 9568 data points collected from a Combined Cycle 
    Power Plant over 6 years (2006-2011), when the power plant was set to 
    work with full load. Features consist of hourly average ambient variables 
    Temperature (T), Ambient Pressure (AP), Relative Humidity (RH) and Exhaust 
    Vacuum (V) to predict the net hourly electrical energy output (EP) of the 
    plant.

    A combined cycle power plant (CCPP) is composed of gas turbines (GT), 
    steam turbines (ST) and heat recovery steam generators. In a CCPP, the 
    electricity is generated by gas and steam turbines, which are combined in 
    one cycle, and is transferred from one turbine to another. While the 
    Vacuum is colected from and has effect on the Steam Turbine, he other 
    three of the ambient variables effect the GT performance.

    For comparability with our baseline studies, and to allow 5x2 fold 
    statistical tests be carried out, we provide the data shuffled five times. 
    For each shuffling 2-fold CV is carried out and the resulting 10 
    measurements are used for statistical testing.

    {BASE_DATASET_DESCRIPTION}

    Features:
        AT (float): 
            Hourly average temperature in Celsius, ranges from 1.81 to 37.11
        V (float): 
            Hourly average exhaust vacuum in cm Hg, ranges from 25.36 to 81.56
        AP (float): 
            Hourly average ambient pressure in millibar, ranges from 992.89 
            to 1033.30
        RH (float): 
            Hourly average relative humidity in percent, ranges from 25.56
            to 100.16

    Targets:
        PE (float): 
            Net hourly electrical energy output in MW, ranges from 420.26
            to 495.76
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Combined+Cycle+Power+Plant

    Examples:
        Load in the data set:
        >>> dataset = PowerPlant()
        >>> dataset.shape
        (9568, 5)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (9568, 4) (9568, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (7615, 4) (7615, 1) (1953, 4) (1953, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00294/CCPP.zip'

    feats = range(4)
    trgts = [4]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the xlsx file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            xlsx = zip_file.read('CCPP/Folds5x2_pp.xlsx')

        # Convert the xlsx bytes into a file-like object
        xlsx_file = io.BytesIO(xlsx)

        # Read the file-like object into a dataframe
        df = pd.read_excel(xlsx_file)
        return df

class FacebookComments(BaseDataset):
    f'''
    Instances in this dataset contain features extracted from Facebook posts. 
    The task associated with the data is to predict how many comments the 
    post will receive.

    {BASE_DATASET_DESCRIPTION}

    Features:
        page_popularity (int):
            Defines the popularity of support for the source of the document
        page_checkins (int): 
            Describes how many individuals so far visited this place. This
            feature is only associated with places; e.g., some institution,
            place, theater, etc.
        page_talking_about (int):
            Defines the daily interest of individuals towards source of the
            document/post. The people who actually come back to the page,
            after liking the page. This include activities such as comments, 
            likes to a post, shares etc., by visitors to the page
        page_category (int):
            Defines the category of the source of the document; e.g., place,
            institution, branch etc.
        agg[n] for n=0..24 (float):
            These features are aggreagted by page, by calculating min, max,
            average, median and standard deviation of essential features
        cc1 (int):
            The total number of comments before selected base date/time
        cc2 (int):
            The number of comments in the last 24 hours, relative to base
            date/time
        cc3 (int):
            The number of comments in the last 48 to last 24 hours relative
            to base date/time
        cc4 (int):
            The number of comments in the first 24 hours after the publication
            of post but before base date/time
        cc5 (int):
            The difference between cc2 and cc3
        base_time (int):
            Selected time in order to simulate the scenario, ranges from 0
            to 71
        post_length (int):
            Character count in the post
        post_share_count (int):
            This feature counts the number of shares of the post, how many 
            people had shared this post onto their timeline
        post_promotion_status (int):
            Binary feature. To reach more people with posts in News Feed,
            individuals can promote their post and this feature indicates
            whether the post is promoted or not
        h_local (int):
            This describes the hours for which we have received the target 
            variable/comments. Ranges from 0 to 23
        day_published[n] for n=0..6 (int):
            Binary feature. This represents the day (Sunday-Saturday) on
            which the post was published
        day[n] for n=0..6 (int):
            Binary feature. This represents the day (Sunday-Saturday) on
            selected base date/time

    Targets:
        ncomments (int): The number of comments in the next `h_local` hours
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Facebook+Comment+Volume+Dataset

    Examples:
        Load in the data set:
        >>> dataset = FacebookComments()
        >>> dataset.shape
        (199030, 54)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (199030, 54) (199030, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (159288, 54) (159288, 1) (39742, 54) (39742, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00363/Dataset.zip'

    feats = range(54)
    trgts = [53]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the csv file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('Dataset/Training/Features_Variant_5.csv')

        # Convert the string into a file-like object
        csv_file = io.BytesIO(csv)

        # Name the columns
        cols = ['page_popularity', 'page_checkins', 'page_talking_about',
                'page_category'] + \
               [f'agg{n}' for n in range(25)] + \
               ['cc1', 'cc2', 'cc3', 'cc4', 'cc5', 'base_time', 'post_length',
                'post_share_count', 'post_promotion_status', 'h_local'] + \
               [f'day_published{n}' for n in range(7)] + \
               [f'day{n}' for n in range(7)] + \
               ['ncomments']

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, header = None, names = cols)
        return df

class FacebookMetrics(BaseDataset):
    f'''
    The data is related to posts' published during the year of 2014 on the 
    Facebook's page of a renowned cosmetics brand.

    {BASE_DATASET_DESCRIPTION}

    Features:
        page_likes(int): 
            The total number of likes of the Facebook page at the given time.
        post_type (int):
            The type of post. Here 0 means 'Photo', 1 means 'Status', 2 means
            'Link' and 3 means 'Video'
        post_category (int):
            The category of the post.
        post_month (int):
            The month the post was posted, from 1 to 12 inclusive.
        post_weekday (int):
            The day of the week the post was posted, from 1 to 7 inclusive.
        post_hour (int):
            The hour the post was posted, from 0 to 23 inclusive
        paid (int):
            Binary feature, whether the post was paid for.

    Targets:
        total_reach (int):
            The lifetime post total reach.
        total_impressions (int):
            The lifetime post total impressions.
        engaged_users (int):
            The lifetime engaged users.
        post_consumers (int):
            The lifetime post consumers.
        post_consumptions (int):
            The lifetime post consumptions.
        post_impressions (int):
            The lifetime post impressions by people who liked the page.
        post_reach (int):
            The lifetime post reach by people who liked the page.
        post_engagements (int):
            The lifetime people who have liked the page and engaged with
            the post.
        comments (int):
            The number of comments.
        shares (int):
            The number of shares.
        total_interactions (int):
            The total number of interactions
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Facebook+metrics 

    Examples:
        Load in the data set:
        >>> dataset = FacebookMetrics()
        >>> dataset.shape
        (500, 19)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (500, 7) (500, 11)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (386, 7) (386, 11) (114, 7) (114, 11)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00368/Facebook_metrics.zip'

    feats = range(7)
    trgts = range(7, 18)

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the csv file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('dataset_Facebook.csv')

        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(csv)

        # Read the file-like object into a dataframe
        cols = ['page_likes', 'post_type', 'post_category', 'post_month',
                'post_weekday', 'post_hour', 'paid', 'total_reach',
                'total_impressions', 'engaged_users', 'post_consumers',
                'post_consumptions', 'post_impressions', 'post_reach',
                'post_engagements', 'comments', 'shares', 'total_interactions']
        df = pd.read_csv(csv_file, sep = ';', names = cols, header = 0,
                         index_col = False)

        # Numericalise post type
        post_types = list(df.post_type.unique())
        df['post_type'] = df.post_type.map(lambda txt: post_types.index(txt))

        return df

class FishBioconcentration(BaseDataset):
    f'''
    This dataset contains manually-curated experimental bioconcentration 
    factor (BCF) for 1058 molecules (continuous values). Each row contains a 
    molecule, identified by a CAS number, a name (if available), and a SMILES 
    string. Additionally, the KOW (experimental or predicted) is reported. In 
    this database, you will also find Extended Connectivity Fingerprints 
    (binary vectors of 1024 bits), to be used as independent variables to 
    predict the BCF.

    {BASE_DATASET_DESCRIPTION}

    Features:
        logkow (float):
            Octanol water paritioning coefficient (experimental or predicted,
            as indicated by ``KOW type``
        kow_exp (int):
            Indicates whether ``logKOW`` is experimental or predicted, with 1
            denoting experimental and 0 denoting predicted
        smiles_[idx] for idx = 0..125 (int):
            Encoding of SMILES string to identify the 2D molecular structure.
            The encoding is as follows, where 'x' is a padding string to
            ensure that all the SMILES strings are of the same length:
                0  = 'x'
                1  = '#'
                2  = '('
                3  = ')'
                4  = '+'
                5  = '-'
                6  = '/'
                7  = '1'
                8  = '2'
                9  = '3'
                10 = '4'
                11 = '5'
                12 = '6'
                13 = '7'
                14 = '8'
                15 = '='
                16 = '@'
                17 = 'B'
                18 = 'C'
                19 = 'F'
                20 = 'H'
                21 = 'I'
                22 = 'N'
                23 = 'O'
                24 = 'P'
                25 = 'S'
                26 = '['
                27 = '\\'
                28 = ']'
                29 = 'c'
                30 = 'i'
                31 = 'l'
                32 = 'n'
                33 = 'o'
                34 = 'r'
                35 = 's'

    Targets:
        logbcf (float): 
            Experimental fish bioconcentration factor (logarithm form)
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/QSAR+fish+bioconcentration+factor+%28BCF%29

    Examples:
        Load in the data set:
        >>> dataset = FishBioconcentration()
        >>> dataset.shape
        (1054, 129)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (1054, 128) (1058, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (819, 128) (819, 1) (235, 128) (235, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00511/QSAR_fish_BCF.zip'

    feats = range(128)
    trgts = [128]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the csv file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('QSAR_BCF_Kow.csv')

        # Convert the string into a file-like object
        csv_file = io.BytesIO(csv)

        # Read the file-like object into a dataframe
        cols = ['cas', 'name', 'smiles', 'logkow', 'kow_exp', 'logbcf']
        df = pd.read_csv(
            csv_file, 
            names = cols, 
            header = 0, 
            usecols = [col for col in cols if col not in ['cas', 'name']]
        )

        # Drop NaNs 
        df = df.dropna()

        # Encode KOW types
        kow_types = ['pred', 'exp']
        df['kow_exp'] = df.kow_exp.map(lambda txt: kow_types.index(txt))

        # Get maximum SMILE string length and pull out all the SMILE string
        # symbols, along with a '-' symbol for padding
        max_smile = max(len(smile_string) for smile_string in df.smiles)
        smile_symbols = ['x'] + sorted({symbol for smile_string in df.smiles
                                        for symbol in set(smile_string)})

        # Pad SMILE strings
        df['smiles'] = [smile_string + 'x' * (max_smile - len(smile_string))
                        for smile_string in df.smiles]

        # Encode SMILE strings
        for idx in range(max_smile):
            df[f'smiles_{idx}'] = df.smiles.map(\
                lambda txt: smile_symbols.index(txt[idx])
            )

        # Drop original SMILE feature
        df = df.drop(columns = 'smiles')

        # Put the target variable at the end
        df = df[
            ['logkow', 'kow_exp'] + \
            [f'smiles_{idx}' for idx in range(max_smile)] + \
            ['logbcf']
        ]

        return df

class FishToxicity(BaseDataset):
    f'''
    This dataset was used to develop quantitative regression QSAR models to 
    predict acute aquatic toxicity towards the fish Pimephales promelas 
    (fathead minnow) on a set of 908 chemicals. LC50 data, which is the 
    concentration that causes death in 50% of test fish over a test duration 
    of 96 hours, was used as model response

    {BASE_DATASET_DESCRIPTION}

    Features:
        CIC0 (float):
            Information indices
        SM1_Dz(Z) (float):
            2D matrix-based descriptors
        GATS1i (float):
            2D autocorrelations
        NdsCH (int)
            Atom-type counts
        NdssC (int)
            Atom-type counts
        MLOGP (float):
            Molecular properties

    Targets:
        LC50 (float): 
            A concentration that causes death in 50% of test fish over a
            test duration of 96 hours. In -log(mol/L) units.
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/QSAR+fish+toxicity

    Examples:
        Load in the data set:
        >>> dataset = FishToxicity()
        >>> dataset.shape
        (908, 7)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (908, 6) (908, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (701, 6) (701, 1) (207, 6) (207, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00504/qsar_fish_toxicity.csv'

    feats = range(6)
    trgts = [6]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a dataframe
        cols = ['CIC0', 'SM1_Dz(Z)', 'GATS1i', 'NdsCH', 
                'NdssC', 'MLOGP', 'LC50']
        df = pd.read_csv(csv_file, sep = ';', header = None, names = cols)

        return df

class ForestFire(BaseDataset):
    f''' 
    This is a difficult regression task, where the aim is to predict the 
    burned area of forest fires, in the northeast region of Portugal, by 
    using meteorological and other data.

    {BASE_DATASET_DESCRIPTION}

    Features:
        X (float): 
            The x-axis spatial coordinate within the Montesinho park map.
            Ranges from 1 to 9.
        Y (float): 
            The y-axis spatial coordinate within the Montesinho park map
            Ranges from 2 to 9.
        month (int):
            Month of the year. Ranges from 0 to 11
        day (int):
            Day of the week. Ranges from 0 to 6
        FFMC (float):
            FFMC index from the FWI system. Ranges from 18.7 to 96.20
        DMC (float):
            DMC index from the FWI system. Ranges from 1.1 to 291.3
        DC (float):
            DC index from the FWI system. Ranges from 7.9 to 860.6
        ISI (float):
            ISI index from the FWI system. Ranges from 0.0 to 56.1
        temp (float):
            Temperature in Celsius degrees. Ranges from 2.2 to 33.3
        RH (float):
            Relative humidity in %. Ranges from 15.0 to 100.0
        wind (float):
            Wind speed in km/h. Ranges from 0.4 to 9.4
        rain (float):
            Outside rain in mm/m2. Ranges from 0.0 to 6.4
    
    Targets:
        area (float):
            The burned area of the forest (in ha). Ranges from 0.00 to 1090.84

    Notes:
        The target variable is very skewed towards 0.0, thus it may make
        sense to model with the logarithm transform.

    Source:
        https://archive.ics.uci.edu/ml/datasets/Forest+Fires

    Examples:
        Load in the data set:
        >>> dataset = ForestFire()
        >>> dataset.shape
        (517, 13)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (517, 12) (517, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (400, 12) (400, 1) (117, 12) (117, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'forest-fires/forestfires.csv'

    feats = range(12)
    trgts = [12]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file)

        # Encode month
        months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                  'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
        df['month'] = df.month.map(lambda string: months.index(string))

        # Encode day
        weekdays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
        df['day'] = df.day.map(lambda string: weekdays.index(string))

        return df

class GasTurbine(BaseDataset):
    f'''
    Data have been generated from a sophisticated simulator of a Gas Turbines 
    (GT), mounted on a Frigate characterized by a COmbined Diesel eLectric 
    And Gas (CODLAG) propulsion plant type.

    The experiments have been carried out by means of a numerical simulator of 
    a naval vessel (Frigate) characterized by a Gas Turbine (GT) propulsion 
    plant. The different blocks forming the complete simulator (Propeller, 
    Hull, GT, Gear Box and Controller) have been developed and fine tuned over 
    the year on several similar real propulsion plants. In view of these 
    observations the available data are in agreement with a possible real 
    vessel.

    In this release of the simulator it is also possible to take into account 
    the performance decay over time of the GT components such as GT compressor 
    and turbines.

    The propulsion system behaviour has been described with this parameters:
        - Ship speed (linear function of the lever position lp).
        - Compressor degradation coefficient kMc.
        - Turbine degradation coefficient kMt.
    so that each possible degradation state can be described by a combination 
    of this triple (lp,kMt,kMc).

    The range of decay of compressor and turbine has been sampled with an 
    uniform grid of precision 0.001 so to have a good granularity of 
    representation.

    In particular for the compressor decay state discretization the kMc 
    coefficient has been investigated in the domain [1; 0.95], and the turbine 
    coefficient in the domain [1; 0.975].

    Ship speed has been investigated sampling the range of feasible speed from 
    3 knots to 27 knots with a granularity of representation equal to tree 
    knots.

    A series of measures (16 features) which indirectly represents of the 
    state of the system subject to performance decay has been acquired and 
    stored in the dataset over the parameter's space.

    {BASE_DATASET_DESCRIPTION}

    Features:
        lever_position (float)
            The position of the lever
        ship_speed (float):
            The ship speed, in knots
        shaft_torque (float):
            The shaft torque of the gas turbine, in kN m
        turbine_revolution_rate (float):
            The gas turbine rate of revolutions, in rpm
        generator_revolution_rate (float):
            The gas generator rate of revolutions, in rpm
        starboard_propeller_torque (float):
            The torque of the starboard propeller, in kN
        port_propeller_torque (float):
            The torque of the port propeller, in kN
        turbine_exit_temp (float):
            Height pressure turbine exit temperature, in celcius
        inlet_temp (float):
            Gas turbine compressor inlet air temperature, in celcius
        outlet_temp (float):
            Gas turbine compressor outlet air temperature, in celcius
        turbine_exit_pres (float):
            Height pressure turbine exit pressure, in bar
        inlet_pres (float):
            Gas turbine compressor inlet air pressure, in bar
        outlet_pres (float):
            Gas turbine compressor outlet air pressure, in bar
        exhaust_pres (float):
            Gas turbine exhaust gas pressure, in bar
        turbine_injection_control (float):
            Turbine injection control, in percent
        fuel_flow (float):
            Fuel flow, in kg/s

    Targets:
        compressor_decay (type): 
            Gas turbine compressor decay state coefficient
        turbine_decay (type): 
            Gas turbine decay state coefficient
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Condition+Based+Maintenance+of+Naval+Propulsion+Plants

    Examples:
        Load in the data set:
        >>> dataset = GasTurbine()
        >>> dataset.shape
        (11934, 18)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (11934, 16) (11934, 2)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (9520, 16) (9520, 2) (2414, 16) (2414, 2)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00316/UCI%20CBM%20Dataset.zip'

    feats = range(16)
    trgts = [16, 17]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the txt file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            txt = zip_file.read('UCI CBM Dataset/data.txt')

        # Decode text and replace initial space on each line
        txt = txt[3:].decode('utf-8').replace('\n   ', '\n')

        # Convert the remaining triple spaces into commas, to make loading
        # it as a csv file easier
        txt = txt.replace('   ', ',')

        # Convert the string into a file-like object
        csv_file = io.StringIO(txt)

        # Read the file-like object into a dataframe
        cols = ['lever_position', 'ship_speed', 'shaft_torque',
                'turbine_revolution_rate', 'generator_revolution_rate',
                'starboard_propeller_torque', 'port_propeller_torque',
                'turbine_exit_temp', 'inlet_temp', 'outlet_temp',
                'turbine_exit_pres', 'inlet_pres', 'outlet_pres',
                'exhaust_pres', 'turbine_injection_control', 'fuel_flow',
                'compressor_decay', 'turbine_decay']
        df = pd.read_csv(csv_file, header = None, names = cols)

        return df

class NewTaipeiHousing(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Real+estate+valuation+data+set 

    Examples:
        Load in the data set:
        >>> dataset = NewTaipeiHousing()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00477/Real%20estate%20valuation%20data%20set.xlsx'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Parkinsons(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Parkinsons+Telemonitoring 

    Examples:
        Load in the data set:
        >>> dataset = Parkinsons()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'parkinsons/telemonitoring/parkinsons_updrs.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Protein(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Physicochemical+Properties+of+Protein+Tertiary+Structure 

    Examples:
        Load in the data set:
        >>> dataset = Protein()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00265/CASP.csv'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Servo(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Servo 

    Examples:
        Load in the data set:
        >>> dataset = Servo()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'servo/servo.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class SolarFlare(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Solar+Flare 

    Examples:
        Load in the data set:
        >>> dataset = Solar()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'solar-flare/flare.data2'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class SpaceShuttle(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Challenger+USA+Space+Shuttle+O-Ring 

    Examples:
        Load in the data set:
        >>> dataset = SpaceShuttle()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'space-shuttle/o-ring-erosion-only.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Stocks(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Stock+portfolio+performance 

    Examples:
        Load in the data set:
        >>> dataset = Stocks()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00390/stock%20portfolio%20performance%20data%20set.xlsx'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Superconductivity(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Superconductivty+Data 

    Examples:
        Load in the data set:
        >>> dataset = Superconductivity()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00464/superconduct.zip'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class TehranHousing(BaseDataset):
    f''' 
    Data set includes construction cost, sale prices, project variables, and 
    economic variables corresponding to real estate single-family residential 
    apartments in Tehran, Iran.

    {BASE_DATASET_DESCRIPTION}

    Features:
        float: 8 project physical and financial variables
        float: 19 economic variables and indices in 5 time lag numbers

    Targets:
        float: Construction cost
        float: Sale price
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Residential+Building+Data+Set 

    Examples:
        Load in the data set:
        >>> dataset = TehranHousing()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00437/Residential-Building-Data-Set.xlsx'

    feats = range(105)
    trgts = [105, 106]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        df = pd.read_excel(data, dtype = float, header = [0, 1])
        return df

class Yacht(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Yacht+Hydrodynamics 

    Examples:
        Load in the data set:
        >>> dataset = Yacht()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00243/yacht_hydrodynamics.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

if __name__ == '__main__':
    dataset = GasTurbine(cache = None)
    print(dataset.shape)

    X, y = dataset.split()
    print(X.shape, y.shape)

    train_test_split = dataset.split(test_size = 0.2, seed = 42)
    X_train, y_train, X_test, y_test = train_test_split
    print(X_train.shape, y_train.shape, X_test.shape, y_test.shape)

    df = dataset.to_pandas()
    print(type(df))

    print(df)
