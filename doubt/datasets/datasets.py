''' 
Collection of data sets for regression tasks, with data preparation pipelines.
All data sets are from the UCI data set archive, with all the descriptions 
being the original descriptions verbatim. Some feature names were constructed
from their descriptions and were not part of the original data set.
'''

from ._dataset import BaseDataset

import pandas as pd
import zipfile
import io

BASE_DATASET_DESCRIPTION = '''
    Parameters:
        cache (str or None):
            The name of the cache. It will be saved to ``cache``.h5 in the
            current working directory. If None then no cache will be saved.
            Defaults to '.cache'.

    Attributes:
        shape (tuple of integers): 
            Dimensions of the data set
        columns (list of strings): 
            List of column names in the data set

    Class attributes:
        url (string):
            The url where the raw data files can be downloaded
        feats (iterable):
            The column indices of the feature variables
        trgts (iterable):
            The column indices of the target variables

    Methods:
        head(n: int = 5) -> pd.DataFrame: 
        to_pandas() -> pandas.DataFrame: 
        close() -> None:
        split(test_size: float or None = None, 
              seed: float or None = None) -> Tuple of Numpy arrays
'''

class Airfoil(BaseDataset):
    f'''
    The NASA data set comprises different size NACA 0012 airfoils at various 
    wind tunnel speeds and angles of attack. The span of the airfoil and the 
    observer position were the same in all of the experiments.   

    {BASE_DATASET_DESCRIPTION}

    Features:
        int: Frequency, in Hertzs
        float: Angle of attack, in degrees
        float: Chord length, in meters
        float: Free-stream velocity, in meters per second
        float: Suction side displacement thickness, in meters

    Targets:
        float: Scaled sound pressure level, in decibels
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Airfoil+Self-Noise 

    Examples:
        Load in the data set:
        >>> dataset = Airfoil()
        >>> dataset.shape
        (1503, 6)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (1503, 5) (1503, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (1179, 5) (1179, 1) (324, 5) (324, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00291/airfoil_self_noise.dat'

    feats = range(5)
    trgts = [5]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a data frame
        df = pd.read_csv(csv_file, sep = '\t', header = None)
        return df

class BikeSharingDaily(BaseDataset):
    f'''
    Bike sharing systems are new generation of traditional bike rentals where 
    whole process from membership, rental and return back has become automatic.
    Through these systems, user is able to easily rent a bike from a 
    particular position and return back at another position. Currently, there 
    are about over 500 bike-sharing programs around the world which is 
    composed of over 500 thousands bicycles. Today, there exists great 
    interest in these systems due to their important role in traffic, 
    environmental and health issues.

    Apart from interesting real world applications of bike sharing systems, 
    the characteristics of data being generated by these systems make them 
    attractive for the research. Opposed to other transport services such as 
    bus or subway, the duration of travel, departure and arrival position is 
    explicitly recorded in these systems. This feature turns bike sharing 
    system into a virtual sensor network that can be used for sensing mobility 
    in the city. Hence, it is expected that most of important events in the 
    city could be detected via monitoring these data. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        instant (int): 
            Record index
        season (int): 
            The season, with 1 = winter, 2 = spring, 3 = summer and 4 = autumn
        yr (int): 
            The year, with 0 = 2011 and 1 = 2012
        mnth (int): 
            The month, from 1 to 12 inclusive
        holiday (int): 
            Whether day is a holiday or not, binary valued
        weekday (int): 
            The day of the week, from 0 to 6 inclusive
        workingday (int): 
            Working day, 1 if day is neither weekend nor holiday, otherwise 0
        weathersit (int): Weather, encoded as follows:
            1: Clear, few clouds, partly cloudy
            2: Mist and cloudy, mist and broken clouds, mist and few clouds
            3: Light snow, light rain and thunderstorm and scattered clouds,
               light rain and scattered clouds
            4: Heavy rain and ice pallets and thunderstorm and mist, or snow
               and fog
        temp (float): 
            Max-min normalised temperature in Celsius, from -8 to +39
        atemp (float): 
            Max-min normalised feeling temperature in Celsius, from -16 to +50
        hum (float): 
            Scaled max-min normalised humidity, from 0 to 1
        windspeed (float): 
            Scaled max-min normalised wind speed, from 0 to 1

    Targets:
        casual (int): 
            Count of casual users
        registered (int): 
            Count of registered users
        cnt (int): 
            Sum of casual and registered users
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset

    Examples:
        Load in the data set:
        >>> dataset = BikeSharingDaily()
        >>> dataset.shape
        (731, 15)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (731, 12) (731, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (562, 12) (562, 3) (169, 12) (169, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00275/Bike-Sharing-Dataset.zip'

    feats = range(12)
    trgts = [12, 13, 14]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out day.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('day.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, usecols = [0] + list(range(2, 16)))
        return df

class BikeSharingHourly(BaseDataset):
    f'''
    Bike sharing systems are new generation of traditional bike rentals where 
    whole process from membership, rental and return back has become automatic.
    Through these systems, user is able to easily rent a bike from a 
    particular position and return back at another position. Currently, there 
    are about over 500 bike-sharing programs around the world which is 
    composed of over 500 thousands bicycles. Today, there exists great 
    interest in these systems due to their important role in traffic, 
    environmental and health issues.

    Apart from interesting real world applications of bike sharing systems, 
    the characteristics of data being generated by these systems make them 
    attractive for the research. Opposed to other transport services such as 
    bus or subway, the duration of travel, departure and arrival position is 
    explicitly recorded in these systems. This feature turns bike sharing 
    system into a virtual sensor network that can be used for sensing mobility 
    in the city. Hence, it is expected that most of important events in the 
    city could be detected via monitoring these data. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        instant (int): 
            Record index
        season (int): 
            The season, with 1 = winter, 2 = spring, 3 = summer and 4 = autumn
        yr (int): 
            The year, with 0 = 2011 and 1 = 2012
        mnth (int): 
            The month, from 1 to 12 inclusive
        hr (int): 
            The hour of the day, from 0 to 23 inclusive
        holiday (int): 
            Whether day is a holiday or not, binary valued
        weekday (int): 
            The day of the week, from 0 to 6 inclusive
        workingday (int): 
            Working day, 1 if day is neither weekend nor holiday, otherwise 0
        weathersit (int): Weather, encoded as follows:
            1: Clear, few clouds, partly cloudy
            2: Mist and cloudy, mist and broken clouds, mist and few clouds
            3: Light snow, light rain and thunderstorm and scattered clouds,
               light rain and scattered clouds
            4: Heavy rain and ice pallets and thunderstorm and mist, or snow
               and fog
        temp (float): 
            Max-min normalised temperature in Celsius, from -8 to +39
        atemp (float): 
            Max-min normalised feeling temperature in Celsius, from -16 to +50
        hum (float): 
            Scaled max-min normalised humidity, from 0 to 1
        windspeed (float): 
            Scaled max-min normalised wind speed, from 0 to 1

    Targets:
        casual (int): 
            Count of casual users
        registered (int): 
            Count of registered users
        cnt (int): 
            Sum of casual and registered users
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset

    Examples:
        Load in the data set:
        >>> dataset = BikeSharingHourly()
        >>> dataset.shape
        (17379, 16)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (17379, 13) (17379, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (13878, 13) (13878, 3) (3501, 13) (3501, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00275/Bike-Sharing-Dataset.zip'

    feats = range(14)
    trgts = [13, 14, 15]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out hour.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('hour.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, usecols = [0] + list(range(2, 17)))
        return df

class Blog(BaseDataset):
    f'''
    This data originates from blog posts. The raw HTML-documents
    of the blog posts were crawled and processed.
    The prediction task associated with the data is the prediction
    of the number of comments in the upcoming 24 hours. In order
    to simulate this situation, we choose a basetime (in the past)
    and select the blog posts that were published at most
    72 hours before the selected base date/time. Then, we calculate
    all the features of the selected blog posts from the information
    that was available at the basetime, therefore each instance
    corresponds to a blog post. The target is the number of
    comments that the blog post received in the next 24 hours
    relative to the basetime.

    In the train data, the basetimes were in the years
    2010 and 2011. In the test data the basetimes were
    in February and March 2012. This simulates the real-world
    situtation in which training data from the past is available
    to predict events in the future.

    The train data was generated from different basetimes that may
    temporally overlap. Therefore, if you simply split the train
    into disjoint partitions, the underlying time intervals may
    overlap. Therefore, the you should use the provided, temporally
    disjoint train and test splits in order to ensure that the
    evaluation is fair.

    {BASE_DATASET_DESCRIPTION}

    Features:
        Features 0-49 (float):
            50 features containing the average, standard deviation,
            minimum, maximum and median of feature 50-59 for the source
            of the current blog post, by which we mean the blog on which
            the post appeared. For example, myblog.blog.org would be the
            source of the post myblog.blog.org/post_2010_09_10
        Feature 50 (int):
            Total number of comments before basetime
        Feature 51 (int):
            Number of comments in the last 24 hours before the basetime
        Feature 52 (int):
            If T1 is the datetime 48 hours before basetime and T2 is the
            datetime 24 hours before basetime, then this is the number of
            comments in the time period between T1 and T2
        Feature 53 (int):
            Number of comments in the first 24 hours after the publication
            of the blog post, but before basetime
        Feature 54 (int):
            The difference between Feature 51 and Feature 52
        Features 55-59 (int):
            The same thing as Features 50-51, but for links (trackbacks)
            instead of comments
        Feature 60 (float):
            The length of time between the publication of the blog post
            and basetime
        Feature 61 (int):
            The length of the blog post
        Features 62-261 (int):
            The 200 bag of words features for 200 frequent words of the
            text of the blog post
        Features 262-268 (int):
            Binary indicators for the weekday (Monday-Sunday) of the basetime
        Features 269-275 (int):
            Binary indicators for the weekday (Monday-Sunday) of the date
            of publication of the blog post
        Feature 276 (int):
            Number of parent pages: we consider a blog post P as a parent
            of blog post B if B is a reply (trackback) to P
        Features 277-279 (float):
            Minimum, maximum and average of the number of comments the
            parents received

    Targets:
        int: The number of comments in the next 24 hours (relative to
             baseline)
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/BlogFeedback 

    Examples:
        Load in the data set:
        >>> dataset = Blog()
        >>> dataset.shape
        (52397, 281)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (52397, 279) (52397, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (41932, 279) (41932, 1) (10465, 279) (10465, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00304/BlogFeedback.zip'

    feats = range(279)
    trgts = [279]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out blogData_train.csv as a string
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('blogData_train.csv').decode('utf-8')

        # Convert the string into a file-like object
        csv_file = io.StringIO(csv)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, header = None)
        return df

class Nanotube(BaseDataset):
    f'''
    CASTEP can simulate a wide range of properties of materials proprieties 
    using density functional theory (DFT). DFT is the most successful method 
    calculates atomic coordinates faster than other mathematical approaches, 
    and it also reaches more accurate results. The dataset is generated with 
    CASTEP using CNT geometry optimization. Many CNTs are simulated in CASTEP, 
    then geometry optimizations are calculated. Initial coordinates of all 
    carbon atoms are generated randomly. Different chiral vectors are used for 
    each CNT simulation. 
    
    The atom type is selected as carbon, bond length is used as 1.42 AÂ° 
    (default value). CNT calculation parameters are used as default 
    parameters. To finalize the computation, CASTEP uses a parameter named 
    as elec_energy_tol (electrical energy tolerance) (default 1x10-5 eV) 
    which represents that the change in the total energy from one iteration to 
    the next remains below some tolerance value per atom for a few 
    self-consistent field steps. Initial atomic coordinates (u, v, w), chiral 
    vector (n, m) and calculated atomic coordinates (u, v, w) are 
    obtained from the output files.

    {BASE_DATASET_DESCRIPTION}

    Features:
        Chiral indice n (int): 
            n parameter of the selected chiral vector
        Chiral indice m (int): 
            m parameter of the selected chiral vector
        Initial atomic coordinate u (float): 
            Randomly generated u parameter of the initial atomic coordinates 
            of all carbon atoms. 
        Initial atomic coordinate v (float): 
            Randomly generated v parameter of the initial atomic coordinates 
            of all carbon atoms. 
        Initial atomic coordinate w (float): 
            Randomly generated w parameter of the initial atomic coordinates 
            of all carbon atoms. 

    Targets:
        Calculated atomic coordinates u (float): 
           Calculated u parameter of the atomic coordinates of all 
           carbon atoms 
        Calculated atomic coordinates v (float): 
           Calculated v parameter of the atomic coordinates of all 
           carbon atoms 
        Calculated atomic coordinates w (float): 
           Calculated w parameter of the atomic coordinates of all 
           carbon atoms 
    
    Sources:
        https://archive.ics.uci.edu/ml/datasets/Carbon+Nanotubes
        https://doi.org/10.1007/s00339-016-0153-1
        https://doi.org/10.17341/gazimmfd.337642

    Examples:
        Load in the data set:
        >>> dataset = Nanotube()
        >>> dataset.shape
        (10721, 8)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (10721, 5) (10721, 3)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (8542, 5) (8542, 3) (2179, 5) (2179, 3)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00448/carbon_nanotubes.csv'

    feats = range(5)
    trgts = [5, 6, 7]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, sep = ';', decimal = ',')
        return df

class Concrete(BaseDataset):
    f'''
    Concrete is the most important material in civil engineering. The concrete 
    compressive strength is a highly nonlinear function of age and 
    ingredients. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        Cement (float): 
            Kg of cement in an m3 mixture
        Blast Furnace Slag (float): 
            Kg of blast furnace slag in an m3 mixture
        Fly Ash (float): 
            Kg of fly ash in an m3 mixture
        Water (float): 
            Kg of water in an m3 mixture
        Superplasticiser (float): 
            Kg of superplasticiser in an m3 mixture
        Coarse Aggregate (float): 
            Kg of coarse aggregate in an m3 mixture
        Fine Aggregate (float): 
            Kg of fine aggregate in an m3 mixture
        Age (int): 
            Age in days, between 1 and 365 inclusive

    Targets:
        Concrete Compressive Strength (float): 
            Concrete compressive strength in megapascals
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Concrete+Compressive+Strength

    Examples:
        Load in the data set:
        >>> dataset = Concrete()
        >>> dataset.shape
        (1030, 9)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (1030, 8) (1030, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (801, 8) (801, 1) (229, 8) (229, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'concrete/compressive/Concrete_Data.xls'

    feats = range(8)
    trgts = [8]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        xls_file = io.BytesIO(data)

        # Load the file-like object into a data frame
        df = pd.read_excel(xls_file)
        return df

class CPU(BaseDataset):
    f'''
    Relative CPU Performance Data, described in terms of its cycle time, 
    memory size, etc. 

    {BASE_DATASET_DESCRIPTION}

    Features:
        vendor_name (string): 
            Name of the vendor, 30 unique values
        model_name (string):
            Name of the model
        myct (int):
            Machine cycle time in nanoseconds
        mmin (int):
            Minimum main memory in kilobytes
        mmax (int):
            Maximum main memory in kilobytes
        cach (int):
            Cache memory in kilobytes
        chmin (int):
            Minimum channels in units
        chmax (int):
            Maximum channels in units

    Targets:
        prp (int):
            Published relative performance
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Computer+Hardware

    Examples:
        Load in the data set:
        >>> dataset = CPU()
        >>> dataset.shape
        (209, 9)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (209, 8) (209, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (158, 8) (158, 1) (51, 8) (51, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'cpu-performance/machine.data'

    feats = range(8)
    trgts = [8]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        csv_file = io.BytesIO(data)

        # Name the columns
        cols = ['vendor_name', 'model_name', 'myct', 'mmin', 'mmax',
                'cach', 'chmin', 'chmax', 'prp']

        # Load the file-like object into a data frame
        df = pd.read_csv(csv_file, header = None, usecols = range(9),
                         names = cols)
        return df

class PowerPlant(BaseDataset):
    f'''
    The dataset contains 9568 data points collected from a Combined Cycle 
    Power Plant over 6 years (2006-2011), when the power plant was set to 
    work with full load. Features consist of hourly average ambient variables 
    Temperature (T), Ambient Pressure (AP), Relative Humidity (RH) and Exhaust 
    Vacuum (V) to predict the net hourly electrical energy output (EP) of the 
    plant.

    A combined cycle power plant (CCPP) is composed of gas turbines (GT), 
    steam turbines (ST) and heat recovery steam generators. In a CCPP, the 
    electricity is generated by gas and steam turbines, which are combined in 
    one cycle, and is transferred from one turbine to another. While the 
    Vacuum is colected from and has effect on the Steam Turbine, he other 
    three of the ambient variables effect the GT performance.

    For comparability with our baseline studies, and to allow 5x2 fold 
    statistical tests be carried out, we provide the data shuffled five times. 
    For each shuffling 2-fold CV is carried out and the resulting 10 
    measurements are used for statistical testing.

    {BASE_DATASET_DESCRIPTION}

    Features:
        AT (float): 
            Hourly average temperature in Celsius, ranges from 1.81 to 37.11
        V (float): 
            Hourly average exhaust vacuum in cm Hg, ranges from 25.36 to 81.56
        AP (float): 
            Hourly average ambient pressure in millibar, ranges from 992.89 
            to 1033.30
        RH (float): 
            Hourly average relative humidity in percent, ranges from 25.56
            to 100.16

    Targets:
        PE (float): 
            Net hourly electrical energy output in MW, ranges from 420.26
            to 495.76
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Combined+Cycle+Power+Plant

    Examples:
        Load in the data set:
        >>> dataset = PowerPlant()
        >>> dataset.shape
        (9568, 5)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (9568, 4) (9568, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (7615, 4) (7615, 1) (1953, 4) (1953, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00294/CCPP.zip'

    feats = range(4)
    trgts = [4]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the xlsx file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            xlsx = zip_file.read('CCPP/Folds5x2_pp.xlsx')

        # Convert the xlsx bytes into a file-like object
        xlsx_file = io.BytesIO(xlsx)

        # Read the file-like object into a dataframe
        df = pd.read_excel(xlsx_file)
        return df

class FacebookComments(BaseDataset):
    f'''
    Instances in this dataset contain features extracted from Facebook posts. 
    The task associated with the data is to predict how many comments the 
    post will receive.

    {BASE_DATASET_DESCRIPTION}

    Features:
        page_popularity (int):
            Defines the popularity of support for the source of the document
        page_checkins (int): 
            Describes how many individuals so far visited this place. This
            feature is only associated with places; e.g., some institution,
            place, theater, etc.
        page_talking_about (int):
            Defines the daily interest of individuals towards source of the
            document/post. The people who actually come back to the page,
            after liking the page. This include activities such as comments, 
            likes to a post, shares etc., by visitors to the page
        page_category (int):
            Defines the category of the source of the document; e.g., place,
            institution, branch etc.
        agg[n] for n=0..24 (float):
            These features are aggreagted by page, by calculating min, max,
            average, median and standard deviation of essential features
        cc1 (int):
            The total number of comments before selected base date/time
        cc2 (int):
            The number of comments in the last 24 hours, relative to base
            date/time
        cc3 (int):
            The number of comments in the last 48 to last 24 hours relative
            to base date/time
        cc4 (int):
            The number of comments in the first 24 hours after the publication
            of post but before base date/time
        cc5 (int):
            The difference between cc2 and cc3
        base_time (int):
            Selected time in order to simulate the scenario, ranges from 0
            to 71
        post_length (int):
            Character count in the post
        post_share_count (int):
            This feature counts the number of shares of the post, how many 
            people had shared this post onto their timeline
        post_promotion_status (int):
            Binary feature. To reach more people with posts in News Feed,
            individuals can promote their post and this feature indicates
            whether the post is promoted or not
        h_local (int):
            This describes the hours for which we have received the target 
            variable/comments. Ranges from 0 to 23
        day_published[n] for n=0..6 (int):
            Binary feature. This represents the day (Sunday-Saturday) on
            which the post was published
        day[n] for n=0..6 (int):
            Binary feature. This represents the day (Sunday-Saturday) on
            selected base date/time

    Targets:
        ncomments (int): The number of comments in the next `h_local` hours
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Facebook+Comment+Volume+Dataset

    Examples:
        Load in the data set:
        >>> dataset = FacebookComments()
        >>> dataset.shape
        (199030, 54)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (199030, 54) (199030, 1)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (159288, 54) (159288, 1) (39742, 54) (39742, 1)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00363/Dataset.zip'

    feats = range(54)
    trgts = [53]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''

        # Convert the bytes into a file-like object
        buffer = io.BytesIO(data)

        # Unzip the file and pull out the csv file
        with zipfile.ZipFile(buffer, 'r') as zip_file:
            csv = zip_file.read('Dataset/Training/Features_Variant_5.csv')

        # Convert the string into a file-like object
        csv_file = io.BytesIO(csv)

        # Name the columns
        cols = ['page_popularity', 'page_checkins', 'page_talking_about',
                'page_category'] + \
               [f'agg{n}' for n in range(25)] + \
               ['cc1', 'cc2', 'cc3', 'cc4', 'cc5', 'base_time', 'post_length',
                'post_share_count', 'post_promotion_status', 'h_local'] + \
               [f'day_published{n}' for n in range(7)] + \
               [f'day{n}' for n in range(7)] + \
               ['ncomments']

        # Read the file-like object into a dataframe
        df = pd.read_csv(csv_file, header = None, names = cols)
        return df

class FacebookMetrics(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Facebook+metrics 

    Examples:
        Load in the data set:
        >>> dataset = FacebookMetrics()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00368/Facebook_metrics.zip'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class FishBioconcentration(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/QSAR+fish+bioconcentration+factor+%28BCF%29 

    Examples:
        Load in the data set:
        >>> dataset = FishBioconcentration()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00511/QSAR_fish_BCF.zip'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class FishToxicity(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/QSAR+fish+toxicity 

    Examples:
        Load in the data set:
        >>> dataset = FishToxicity()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00504/qsar_fish_toxicity.csv'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class ForestFire(BaseDataset):
    f''' 
    This is a difficult regression task, where the aim is to predict the 
    burned area of forest fires, in the northeast region of Portugal, by 
    using meteorological and other data.

    {BASE_DATASET_DESCRIPTION}

    Features:
        X (float): 
            The x-axis spatial coordinate within the Montesinho park map.
            Ranges from 1 to 9.
        Y (float): 
            The y-axis spatial coordinate within the Montesinho park map
            Ranges from 2 to 9.
        month (str):
            Month of the year. Ranges from 'jan' to 'dec'
        day (str):
            Day of the year. Ranges from 'mon' to 'sun'
        FFMC (float):
            FFMC index from the FWI system. Ranges from 18.7 to 96.20
        DMC (float):
            DMC index from the FWI system. Ranges from 1.1 to 291.3
        DC (float):
            DC index from the FWI system. Ranges from 7.9 to 860.6
        ISI (float):
            ISI index from the FWI system. Ranges from 0.0 to 56.1
        temp (float):
            Temperature in Celsius degrees. Ranges from 2.2 to 33.3
        RH (float):
            Relative humidity in %. Ranges from 15.0 to 100.0
        wind (float):
            Wind speed in km/h. Ranges from 0.4 to 9.4
        rain (float):
            Outside rain in mm/m2. Ranges from 0.0 to 6.4
    
    Targets:
        area (float):
            The burned area of the forest (in ha). Ranges from 0.00 to 1090.84

    Notes:
        The target variable is very skewed towards 0.0, thus it may make
        sense to model with the logarithm transform.

    Source:
        https://archive.ics.uci.edu/ml/datasets/Forest+Fires 

    Examples:
        Load in the data set:
        >>> dataset = ForestFire()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'forest-fires/forestfires.csv'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class GasTurbine(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Condition+Based+Maintenance+of+Naval+Propulsion+Plants 

    Examples:
        Load in the data set:
        >>> dataset = GasTurbine()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00316/UCI%20CBM%20Dataset.zip'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class NewTaipeiHousing(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Real+estate+valuation+data+set 

    Examples:
        Load in the data set:
        >>> dataset = NewTaipeiHousing()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00477/Real%20estate%20valuation%20data%20set.xlsx'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Parkinsons(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Parkinsons+Telemonitoring 

    Examples:
        Load in the data set:
        >>> dataset = Parkinsons()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'parkinsons/telemonitoring/parkinsons_updrs.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Protein(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Physicochemical+Properties+of+Protein+Tertiary+Structure 

    Examples:
        Load in the data set:
        >>> dataset = Protein()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00265/CASP.csv'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Servo(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Servo 

    Examples:
        Load in the data set:
        >>> dataset = Servo()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'servo/servo.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class SolarFlare(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Solar+Flare 

    Examples:
        Load in the data set:
        >>> dataset = Solar()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'solar-flare/flare.data2'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class SpaceShuttle(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Challenger+USA+Space+Shuttle+O-Ring 

    Examples:
        Load in the data set:
        >>> dataset = SpaceShuttle()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          'space-shuttle/o-ring-erosion-only.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Stocks(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Stock+portfolio+performance 

    Examples:
        Load in the data set:
        >>> dataset = Stocks()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00390/stock%20portfolio%20performance%20data%20set.xlsx'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class Superconductivity(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Superconductivty+Data 

    Examples:
        Load in the data set:
        >>> dataset = Superconductivity()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00464/superconduct.zip'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

class TehranHousing(BaseDataset):
    f''' 
    Data set includes construction cost, sale prices, project variables, and 
    economic variables corresponding to real estate single-family residential 
    apartments in Tehran, Iran.

    {BASE_DATASET_DESCRIPTION}

    Features:
        float: 8 project physical and financial variables
        float: 19 economic variables and indices in 5 time lag numbers

    Targets:
        float: Construction cost
        float: Sale price
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Residential+Building+Data+Set 

    Examples:
        Load in the data set:
        >>> dataset = TehranHousing()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    '''

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00437/Residential-Building-Data-Set.xlsx'

    feats = range(105)
    trgts = [105, 106]

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        df = pd.read_excel(data, dtype = float, header = [0, 1])
        return df

class Yacht(BaseDataset):
    f'''
    Description

    {BASE_DATASET_DESCRIPTION}

    Features:
        name (type): 
            Description

    Targets:
        name (type): 
            Description
    
    Source:
        https://archive.ics.uci.edu/ml/datasets/Yacht+Hydrodynamics 

    Examples:
        Load in the data set:
        >>> dataset = Yacht()
        >>> dataset.shape
        (?, ?)

        Split the data set into features and targets, as NumPy arrays:
        >>> X, y = dataset.split()
        >>> X.shape, y.shape
        (?, ?) (?, ?)

        Perform a train/test split, also outputting NumPy arrays:
        >>> train_test_split = dataset.split(test_size = 0.2, seed = 42)
        >>> X_train, y_train, X_test, y_test = train_test_split
        >>> X_train.shape, y_train.shape, X_test.shape, y_test.shape
        (?, ?) (?, ?) (?, ?) (?, ?)

        Output the underlying Pandas DataFrame:
        >>> df = dataset.to_pandas()
        >>> type(df)
        <class 'pandas.core.frame.DataFrame'>
    ''' 

    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/'\
          '00243/yacht_hydrodynamics.data'

    feats = []
    trgts = []

    def _prep_data(self, data: bytes) -> pd.DataFrame:
        ''' Prepare the data set.

        Args:
            data (bytes): The raw data

        Returns:
            Pandas dataframe: The prepared data
        '''
        raise NotImplementedError

if __name__ == '__main__':
    dataset = FacebookComments(cache = None)
    print(dataset.shape)

    X, y = dataset.split()
    print(X.shape, y.shape)

    train_test_split = dataset.split(test_size = 0.2, seed = 42)
    X_train, y_train, X_test, y_test = train_test_split
    print(X_train.shape, y_train.shape, X_test.shape, y_test.shape)

    df = dataset.to_pandas()
    print(type(df))
